{"version":3,"sources":["webpack:///./node_modules/prismjs/components/prism-csharp.js"],"names":["Prism","replace","pattern","replacements","m","index","re","flags","RegExp","nested","depthLog2","i","keywordKinds","type","typeDeclaration","contextual","other","keywordsToPattern","words","trim","typeDeclarationKeywords","keywords","nonTypeKeywords","nonContextualKeywords","generic","source","nestedRound","name","genericName","identifier","array","typeExpressionWithoutTuple","tupleElement","tuple","typeExpression","typeInside","character","regularString","verbatimString","languages","csharp","extend","lookbehind","greedy","alias","inside","insertBefore","regularStringOrCharacter","regularStringCharacterOrComment","roundExpression","attrTarget","attr","formatString","mInterpolationRound","mInterpolation","sInterpolationRound","sInterpolation","createInterpolationInside","interpolation","interpolationRound","dotnet","cs"],"mappings":"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","file":"js/chunk-2d0e5758.0eebcec8.js","sourcesContent":["(function (Prism) {\n\n\t/**\n\t * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\n\t *\n\t * Note: This is a simple text based replacement. Be careful when using backreferences!\n\t *\n\t * @param {string} pattern the given pattern.\n\t * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.\n\t * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.\n\t * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\n\t */\n\tfunction replace(pattern, replacements) {\n\t\treturn pattern.replace(/<<(\\d+)>>/g, function (m, index) {\n\t\t\treturn '(?:' + replacements[+index] + ')';\n\t\t});\n\t}\n\t/**\n\t * @param {string} pattern\n\t * @param {string[]} replacements\n\t * @param {string} [flags]\n\t * @returns {RegExp}\n\t */\n\tfunction re(pattern, replacements, flags) {\n\t\treturn RegExp(replace(pattern, replacements), flags || '');\n\t}\n\n\t/**\n\t * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n\t *\n\t * @param {string} pattern\n\t * @param {number} depthLog2\n\t * @returns {string}\n\t */\n\tfunction nested(pattern, depthLog2) {\n\t\tfor (var i = 0; i < depthLog2; i++) {\n\t\t\tpattern = pattern.replace(/<<self>>/g, function () { return '(?:' + pattern + ')'; });\n\t\t}\n\t\treturn pattern.replace(/<<self>>/g, '[^\\\\s\\\\S]');\n\t}\n\n\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/\n\tvar keywordKinds = {\n\t\t// keywords which represent a return or variable type\n\t\ttype: 'bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void',\n\t\t// keywords which are used to declare a type\n\t\ttypeDeclaration: 'class enum interface struct',\n\t\t// contextual keywords\n\t\t// (\"var\" and \"dynamic\" are missing because they are used like types)\n\t\tcontextual: 'add alias and ascending async await by descending from get global group into join let nameof not notnull on or orderby partial remove select set unmanaged value when where where',\n\t\t// all other keywords\n\t\tother: 'abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield'\n\t};\n\n\t// keywords\n\tfunction keywordsToPattern(words) {\n\t\treturn '\\\\b(?:' + words.trim().replace(/ /g, '|') + ')\\\\b';\n\t}\n\tvar typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);\n\tvar keywords = RegExp(keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other));\n\tvar nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other);\n\tvar nonContextualKeywords = keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.other);\n\n\t// types\n\tvar generic = nested(/<(?:[^<>;=+\\-*/%&|^]|<<self>>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.\n\tvar nestedRound = nested(/\\((?:[^()]|<<self>>)*\\)/.source, 2);\n\tvar name = /@?\\b[A-Za-z_]\\w*\\b/.source;\n\tvar genericName = replace(/<<0>>(?:\\s*<<1>>)?/.source, [name, generic]);\n\tvar identifier = replace(/(?!<<0>>)<<1>>(?:\\s*\\.\\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);\n\tvar array = /\\[\\s*(?:,\\s*)*\\]/.source;\n\tvar typeExpressionWithoutTuple = replace(/<<0>>(?:\\s*(?:\\?\\s*)?<<1>>)*(?:\\s*\\?)?/.source, [identifier, array]);\n\tvar tupleElement = replace(/[^,()<>[\\];=+\\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array])\n\tvar tuple = replace(/\\(<<0>>+(?:,<<0>>+)+\\)/.source, [tupleElement]);\n\tvar typeExpression = replace(/(?:<<0>>|<<1>>)(?:\\s*(?:\\?\\s*)?<<2>>)*(?:\\s*\\?)?/.source, [tuple, identifier, array]);\n\n\tvar typeInside = {\n\t\t'keyword': keywords,\n\t\t'punctuation': /[<>()?,.:[\\]]/\n\t};\n\n\t// strings & characters\n\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals\n\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals\n\tvar character = /'(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'/.source; // simplified pattern\n\tvar regularString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/.source;\n\tvar verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\n\n\n\tPrism.languages.csharp = Prism.languages.extend('clike', {\n\t\t'string': [\n\t\t\t{\n\t\t\t\tpattern: re(/(^|[^$\\\\])<<0>>/.source, [verbatimString]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: re(/(^|[^@$\\\\])<<0>>/.source, [regularString]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: RegExp(character),\n\t\t\t\tgreedy: true,\n\t\t\t\talias: 'character'\n\t\t\t}\n\t\t],\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\t// Using static\n\t\t\t\t// using static System.Math;\n\t\t\t\tpattern: re(/(\\busing\\s+static\\s+)<<0>>(?=\\s*;)/.source, [identifier]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: typeInside\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Using alias (type)\n\t\t\t\t// using Project = PC.MyCompany.Project;\n\t\t\t\tpattern: re(/(\\busing\\s+<<0>>\\s*=\\s*)<<1>>(?=\\s*;)/.source, [name, typeExpression]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: typeInside\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Using alias (alias)\n\t\t\t\t// using Project = PC.MyCompany.Project;\n\t\t\t\tpattern: re(/(\\busing\\s+)<<0>>(?=\\s*=)/.source, [name]),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Type declarations\n\t\t\t\t// class Foo<A, B>\n\t\t\t\t// interface Foo<out A, B>\n\t\t\t\tpattern: re(/(\\b<<0>>\\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: typeInside\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Single catch exception declaration\n\t\t\t\t// catch(Foo)\n\t\t\t\t// (things like catch(Foo e) is covered by variable declaration)\n\t\t\t\tpattern: re(/(\\bcatch\\s*\\(\\s*)<<0>>/.source, [identifier]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: typeInside\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Name of the type parameter of generic constraints\n\t\t\t\t// where Foo : class\n\t\t\t\tpattern: re(/(\\bwhere\\s+)<<0>>/.source, [name]),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Casts and checks via as and is.\n\t\t\t\t// as Foo<A>, is Bar<B>\n\t\t\t\t// (things like if(a is Foo b) is covered by variable declaration)\n\t\t\t\tpattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<<0>>/.source, [typeExpressionWithoutTuple]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: typeInside\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Variable, field and parameter declaration\n\t\t\t\t// (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)\n\t\t\t\tpattern: re(/\\b<<0>>(?=\\s+(?!<<1>>)<<2>>(?:\\s*[=,;:{)\\]]|\\s+(?:in|when)\\b))/.source, [typeExpression, nonContextualKeywords, name]),\n\t\t\t\tinside: typeInside\n\t\t\t}\n\t\t],\n\t\t'keyword': keywords,\n\t\t// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals\n\t\t'number': /(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:ul|lu|[dflmu])?\\b/i,\n\t\t'operator': />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n\t\t'punctuation': /\\?\\.?|::|[{}[\\];(),.:]/\n\t});\n\n\tPrism.languages.insertBefore('csharp', 'number', {\n\t\t'range': {\n\t\t\tpattern: /\\.\\./,\n\t\t\talias: 'operator'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('csharp', 'punctuation', {\n\t\t'named-parameter': {\n\t\t\tpattern: re(/([(,]\\s*)<<0>>(?=\\s*:)/.source, [name]),\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('csharp', 'class-name', {\n\t\t'namespace': {\n\t\t\t// namespace Foo.Bar {}\n\t\t\t// using Foo.Bar;\n\t\t\tpattern: re(/(\\b(?:namespace|using)\\s+)<<0>>(?:\\s*\\.\\s*<<0>>)*(?=\\s*[;{])/.source, [name]),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'type-expression': {\n\t\t\t// default(Foo), typeof(Foo<Bar>), sizeof(int)\n\t\t\tpattern: re(/(\\b(?:default|typeof|sizeof)\\s*\\(\\s*)(?:[^()\\s]|\\s(?!\\s*\\))|<<0>>)*(?=\\s*\\))/.source, [nestedRound]),\n\t\t\tlookbehind: true,\n\t\t\talias: 'class-name',\n\t\t\tinside: typeInside\n\t\t},\n\t\t'return-type': {\n\t\t\t// Foo<Bar> ForBar(); Foo IFoo.Bar() => 0\n\t\t\t// int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];\n\t\t\t// int Foo => 0; int Foo { get; set } = 0;\n\t\t\tpattern: re(/<<0>>(?=\\s+(?:<<1>>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source, [typeExpression, identifier]),\n\t\t\tinside: typeInside,\n\t\t\talias: 'class-name'\n\t\t},\n\t\t'constructor-invocation': {\n\t\t\t// new List<Foo<Bar[]>> { }\n\t\t\tpattern: re(/(\\bnew\\s+)<<0>>(?=\\s*[[({])/.source, [typeExpression]),\n\t\t\tlookbehind: true,\n\t\t\tinside: typeInside,\n\t\t\talias: 'class-name'\n\t\t},\n\t\t/*'explicit-implementation': {\n\t\t\t// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();\n\t\t\tpattern: replace(/\\b<<0>>(?=\\.<<1>>)/, className, methodOrPropertyDeclaration),\n\t\t\tinside: classNameInside,\n\t\t\talias: 'class-name'\n\t\t},*/\n\t\t'generic-method': {\n\t\t\t// foo<Bar>()\n\t\t\tpattern: re(/<<0>>\\s*<<1>>(?=\\s*\\()/.source, [name, generic]),\n\t\t\tinside: {\n\t\t\t\t'function': re(/^<<0>>/.source, [name]),\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: RegExp(generic),\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: typeInside\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'type-list': {\n\t\t\t// The list of types inherited or of generic constraints\n\t\t\t// class Foo<F> : Bar, IList<FooBar>\n\t\t\t// where F : Bar, IList<int>\n\t\t\tpattern: re(\n\t\t\t\t/\\b((?:<<0>>\\s+<<1>>|where\\s+<<2>>)\\s*:\\s*)(?:<<3>>|<<4>>)(?:\\s*,\\s*(?:<<3>>|<<4>>))*(?=\\s*(?:where|[{;]|=>|$))/.source,\n\t\t\t\t[typeDeclarationKeywords, genericName, name, typeExpression, keywords.source]\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'keyword': keywords,\n\t\t\t\t'class-name': {\n\t\t\t\t\tpattern: RegExp(typeExpression),\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\tinside: typeInside\n\t\t\t\t},\n\t\t\t\t'punctuation': /,/\n\t\t\t}\n\t\t},\n\t\t'preprocessor': {\n\t\t\tpattern: /(^\\s*)#.*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'property',\n\t\t\tinside: {\n\t\t\t\t// highlight preprocessor directives as keywords\n\t\t\t\t'directive': {\n\t\t\t\t\tpattern: /(\\s*#)\\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\\b/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'keyword'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// attributes\n\tvar regularStringOrCharacter = regularString + '|' + character;\n\tvar regularStringCharacterOrComment = replace(/\\/(?![*/])|\\/\\/[^\\r\\n]*[\\r\\n]|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>/.source, [regularStringOrCharacter]);\n\tvar roundExpression = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [regularStringCharacterOrComment]), 2);\n\n\t// https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets\n\tvar attrTarget = /\\b(?:assembly|event|field|method|module|param|property|return|type)\\b/.source;\n\tvar attr = replace(/<<0>>(?:\\s*\\(<<1>>*\\))?/.source, [identifier, roundExpression]);\n\n\tPrism.languages.insertBefore('csharp', 'class-name', {\n\t\t'attribute': {\n\t\t\t// Attributes\n\t\t\t// [Foo], [Foo(1), Bar(2, Prop = \"foo\")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]\n\t\t\tpattern: re(/((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<<0>>\\s*:\\s*)?<<1>>(?:\\s*,\\s*<<1>>)*(?=\\s*\\])/.source, [attrTarget, attr]),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'target': {\n\t\t\t\t\tpattern: re(/^<<0>>(?=\\s*:)/.source, [attrTarget]),\n\t\t\t\t\talias: 'keyword'\n\t\t\t\t},\n\t\t\t\t'attribute-arguments': {\n\t\t\t\t\tpattern: re(/\\(<<0>>*\\)/.source, [roundExpression]),\n\t\t\t\t\tinside: Prism.languages.csharp\n\t\t\t\t},\n\t\t\t\t'class-name': {\n\t\t\t\t\tpattern: RegExp(identifier),\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /\\./\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'punctuation': /[:,]/\n\t\t\t}\n\t\t}\n\t});\n\n\n\t// string interpolation\n\tvar formatString = /:[^}\\r\\n]+/.source;\n\t// multi line\n\tvar mInterpolationRound = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [regularStringCharacterOrComment]), 2)\n\tvar mInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [mInterpolationRound, formatString]);\n\t// single line\n\tvar sInterpolationRound = nested(replace(/[^\"'/()]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>|\\(<<self>>*\\)/.source, [regularStringOrCharacter]), 2)\n\tvar sInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [sInterpolationRound, formatString]);\n\n\tfunction createInterpolationInside(interpolation, interpolationRound) {\n\t\treturn {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: re(/((?:^|[^{])(?:\\{\\{)*)<<0>>/.source, [interpolation]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'format-string': {\n\t\t\t\t\t\tpattern: re(/(^\\{(?:(?![}:])<<0>>)*)<<1>>(?=\\}$)/.source, [interpolationRound, formatString]),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'punctuation': /^:/\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t'punctuation': /^\\{|\\}$/,\n\t\t\t\t\t'expression': {\n\t\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\t\talias: 'language-csharp',\n\t\t\t\t\t\tinside: Prism.languages.csharp\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t};\n\t}\n\n\tPrism.languages.insertBefore('csharp', 'string', {\n\t\t'interpolation-string': [\n\t\t\t{\n\t\t\t\tpattern: re(/(^|[^\\\\])(?:\\$@|@\\$)\"(?:\"\"|\\\\[\\s\\S]|\\{\\{|<<0>>|[^\\\\{\"])*\"/.source, [mInterpolation]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: createInterpolationInside(mInterpolation, mInterpolationRound),\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: re(/(^|[^@\\\\])\\$\"(?:\\\\.|\\{\\{|<<0>>|[^\\\\\"{])*\"/.source, [sInterpolation]),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: createInterpolationInside(sInterpolation, sInterpolationRound),\n\t\t\t}\n\t\t]\n\t});\n\n}(Prism));\n\nPrism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;\n"],"sourceRoot":""}